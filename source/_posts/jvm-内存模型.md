---
title: jvm-内存模型
date: 2021-02-10 19:21:46
tags:
---

#### 内存模型

![img](https://pic1.zhimg.com/80/v2-354d31865d1fb3362f5a1ca938f9a770_1440w.jpg)

##### 程序计数器

存放当前执行字节码地址。一个处理器只会执行一条指令，因此多线程切换上下文的时候为了能正确执行下一条指令，各个线程需要独立存储，故这块是**线程私有**

##### Java虚拟机栈

线程私有，生命周期和线程一样，描述的是方法运行的内存模型，每个方法在执行的时候都会创建一个**栈帧**用于存储局部变量、动态链接、方法出口等信息。每个方法的执行与结束都对应**栈帧**的入栈、出栈。

局部变量表存放了各种基本数据类型和对象应用（reference类型），其中64位的long数据会占用2个局部变量（slot）。局部变量表所需的空间在编译期间完成分配，当进去一个方法时，所需的空间是确定的，故当方法递归次数过多的时候存在栈溢出分险。

##### 本地方法栈

与Java虚拟机栈类似，不同之处在于服务对象是本地方法，不是Java方法。

##### Java堆

绝大部分对象在这里分配，按照垃圾回收模式可将堆分为：eden、survivor

##### 方法区

线程共享，用户存储虚拟机加载的类、常量、静态变量、编译后的代码数据等，为Java堆的逻辑部分，别名Non-heap 为了和堆区分。通过反射获取到的类型、方法名、字段名称、访问修饰符等信息就是从方法区获取到的。在jdk1.8中也就是Metaspace内存溢出，可以通过参数JVM参数-XX:MetaspaceSize和-XX:MaxMetaspaceSize设置Metaspace的空间大小。jdk1.8后**方法区（Method Area）**被元空间(Metaspace)代替。

##### 运行时常量池

方法区的一部分，用于存放编译时的生成的字面量、符号引用，

##### 对象的创建

？

##### 对象的内存布局

对象头、实例数据、对齐填充。

对象头：1、对象自身运行时数据，如hashcode、锁标志、gc分代年龄等等。2、类型指针，指向类的元数据。

实例数据：代码定义的数据，默认分配顺序：long/double、int、short、chart、bytes/boolean、

对齐空间：占位符，对象的起始地址必须是8的倍数，故对象的存储空间必须是8的倍数，对象头一般是8/16，但是实例数据不一定，故需要对齐空间。

##### 对象的访问定位

###### 具柄方式

reference指向堆中生成句柄池地址，包含实例地址、类型地址。

###### 直接指针（hotspot）

reference存放的是对象的地址，对象里面存放到对象类型的指针