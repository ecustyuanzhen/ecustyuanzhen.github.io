<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-jvm-内存模型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/02/10/jvm-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" class="article-date">
  <time datetime="2021-02-10T11:21:46.000Z" itemprop="datePublished">2021-02-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/02/10/jvm-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">jvm-内存模型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h4><p><img src="https://pic1.zhimg.com/80/v2-354d31865d1fb3362f5a1ca938f9a770_1440w.jpg" alt="img"></p>
<h5 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h5><p>存放当前执行字节码地址。一个处理器只会执行一条指令，因此多线程切换上下文的时候为了能正确执行下一条指令，各个线程需要独立存储，故这块是<strong>线程私有</strong></p>
<h5 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h5><p>线程私有，生命周期和线程一样，描述的是方法运行的内存模型，每个方法在执行的时候都会创建一个<strong>栈帧</strong>用于存储局部变量、动态链接、方法出口等信息。每个方法的执行与结束都对应<strong>栈帧</strong>的入栈、出栈。</p>
<p>局部变量表存放了各种基本数据类型和对象应用（reference类型），其中64位的long数据会占用2个局部变量（slot）。局部变量表所需的空间在编译期间完成分配，当进去一个方法时，所需的空间是确定的，故当方法递归次数过多的时候存在栈溢出分险。</p>
<h5 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h5><p>与Java虚拟机栈类似，不同之处在于服务对象是本地方法，不是Java方法。</p>
<h5 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h5><p>绝大部分对象在这里分配，按照垃圾回收模式可将堆分为：eden、survivor</p>
<h5 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h5><p>线程共享，用户存储虚拟机加载的类、常量、静态变量、编译后的代码数据等，为Java堆的逻辑部分，别名Non-heap 为了和堆区分。通过反射获取到的类型、方法名、字段名称、访问修饰符等信息就是从方法区获取到的。在jdk1.8中也就是Metaspace内存溢出，可以通过参数JVM参数-XX:MetaspaceSize和-XX:MaxMetaspaceSize设置Metaspace的空间大小。jdk1.8后<strong>方法区（Method Area）</strong>被元空间(Metaspace)代替。</p>
<h5 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><p>方法区的一部分，用于存放编译时的生成的字面量、符号引用，</p>
<h5 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h5><p>？</p>
<h5 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h5><p>对象头、实例数据、对齐填充。</p>
<p>对象头：1、对象自身运行时数据，如hashcode、锁标志、gc分代年龄等等。2、类型指针，指向类的元数据。</p>
<p>实例数据：代码定义的数据，默认分配顺序：long/double、int、short、chart、bytes/boolean、</p>
<p>对齐空间：占位符，对象的起始地址必须是8的倍数，故对象的存储空间必须是8的倍数，对象头一般是8/16，但是实例数据不一定，故需要对齐空间。</p>
<h5 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h5><h6 id="具柄方式"><a href="#具柄方式" class="headerlink" title="具柄方式"></a>具柄方式</h6><p>reference指向堆中生成句柄池地址，包含实例地址、类型地址。</p>
<h6 id="直接指针（hotspot）"><a href="#直接指针（hotspot）" class="headerlink" title="直接指针（hotspot）"></a>直接指针（hotspot）</h6><p>reference存放的是对象的地址，对象里面存放到对象类型的指针</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/10/jvm-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" data-id="ckl3fedns0000aym08yv10dje" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ThradPoolExecutor" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/02/10/ThradPoolExecutor/" class="article-date">
  <time datetime="2021-02-10T03:09:49.000Z" itemprop="datePublished">2021-02-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/02/10/ThradPoolExecutor/">ThradPoolExecutor</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img src="https://p1.meituan.net/travelcube/912883e51327e0c7a9d753d11896326511272.png" alt="图1 ThreadPoolExecutor UML类图"></p>
<p>ThreadPoolExecutor实现的顶层接口是<strong>Executor</strong>，顶层接口Executor提供了一种思想：将任务提交和任务执行进行解耦。用户无需关注如何创建线程，如何调度线程来执行任务，用户只需提供Runnable对象，将任务的运行逻辑提交到执行器(Executor)中，由Executor框架完成线程的调配和任务的执行部分。<strong>ExecutorService</strong>接口增加了一些能力：（1）扩充执行任务的能力，补充可以为一个或一批异步任务生成Future的方法；（2）提供了管控线程池的方法，比如停止线程池的运行。<strong>AbstractExecutorService</strong>则是上层的抽象类，将执行任务的流程串联了起来，保证下层的实现只需关注一个执行任务的方法即可。最下层的实现类<strong>ThreadPoolExecutor</strong>实现最复杂的运行部分，ThreadPoolExecutor将会一方面维护自身的生命周期，另一方面同时管理线程和任务，使两者良好的结合从而执行并行任务。</p>
<h4 id="运行流程图"><a href="#运行流程图" class="headerlink" title="运行流程图"></a>运行流程图</h4><p><img src="https://p0.meituan.net/travelcube/77441586f6b312a54264e3fcf5eebe2663494.png" alt="图2 ThreadPoolExecutor运行流程"></p>
<p>线程池在内部实际上构建了一个生产者消费者模型，将线程和任务两者解耦，并不直接关联，从而良好的缓冲任务，复用线程。线程池的运行主要分成两部分：任务管理、线程管理。任务管理部分充当生产者的角色，当任务提交后，线程池会判断该任务后续的流转：（1）直接申请线程执行该任务；（2）缓冲到队列中等待线程执行；（3）拒绝该任务。线程管理部分是消费者，它们被统一维护在线程池内，根据任务请求进行线程的分配，当线程执行完任务后则会继续获取新的任务去执行，最终当线程获取不到任务的时候，线程就会被回收。</p>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><h5 id="coresize"><a href="#coresize" class="headerlink" title="coresize"></a>coresize</h5><p>默认情况下，只有任务到来的时候才会创建core thrad，但是可以通过方法， prestartCoreThread or prestartAllCoreThreads 来重写</p>
<h5 id="maxsize"><a href="#maxsize" class="headerlink" title="maxsize"></a>maxsize</h5><p>当一个新的任务过来后，</p>
<ul>
<li><p>如果当前线程池的size小于core，那么即使池子里有空闲线程，也会创建新的线程来处理；</p>
</li>
<li><p>如果当前线程池的size大于core但是小于max，那么只有队列满了后才会创建新的线程。</p>
</li>
</ul>
<p><strong>Keep-alive times</strong></p>
<p>默认情况，当线程池线程数量超过core，那么多余的线程在空闲Keep-alive times 后会被回收，但是 通过方法allowCoreThreadTimeOut(boolean) </p>
<p> 可以回收core thrad。<br><strong>Queuing</strong></p>
<ul>
<li><p>如果当前线程数小于core，直接创建线程</p>
</li>
<li><p>如果当前线程数小于max，进去queue，</p>
</li>
<li><p>如果queue已经满了，此时若线程数量小于max则直接创建，若大于max则reject</p>
</li>
</ul>
<p>通常有三种队列策略：</p>
<ol>
<li><p>直接移交</p>
<p>工作队列的一个很好的默认选择是SynchronousQueue，它可以将任务移交给线程，而不必另外保留它们。适用于并发提高响应速度的场景，但是需要core、maxsize足够大。</p>
</li>
<li><p>无界队列</p>
<p> 例如 LinkedBlockingQueu，此时max的参数不再工作，所有任务进去队列</p>
</li>
<li><p>有界队列</p>
<p> ArrayBlockingQueue</p>
</li>
</ol>
<h5 id="Rejected-tasks"><a href="#Rejected-tasks" class="headerlink" title="Rejected tasks"></a>Rejected tasks</h5><p>存在4种拒绝策略</p>
<ol>
<li><p>中止（默认）</p>
<p>抛出异常</p>
</li>
<li><p>调用者运行</p>
</li>
<li><p>抛弃</p>
</li>
<li><p>抛弃最旧的</p>
</li>
</ol>
<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>线程池内部使用一个变量维护两个值：<strong>运行状态(**runState)和</strong>线程数量** (workerCount)。在具体实现中，线程池将运行状态(runState)、线程数量 (workerCount)两个关键参数的维护放在了一起。</p>
<p><code>ctl</code>这个AtomicInteger类型，是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段， 它同时包含两部分的信息：线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)，高3位保存runState，低29位保存workerCount，两个变量之间互不干扰。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Packing and unpacking ctl</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure>

<h5 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h5><ul>
<li>RUNNING：接受新任务并处理排队任务</li>
<li>SHUTDOWN：不接受新任务，但处理排队任务</li>
<li>STOP：不接受新任务、不处理排队任务、中断正在进行的任务</li>
<li>TIDING：所有任务都已终止、workerCount为0时，线程会切换到TIDING、并运行 terminate() 钩子方法</li>
<li>TERMINATED：terminate() 运行完成</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/10/ThradPoolExecutor/" data-id="ckkz7f7yy0000czm00l8033b9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-设计模式-代理模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2020-12-18T15:55:52.000Z" itemprop="datePublished">2020-12-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/">设计模式-代理模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>为其他对象提供一种代理以控制对这个对象的访问。</p>
<p>代理模式，即Proxy，它和Adapter模式很类似。Adapter模式:它用于把A接口转换为B接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BAdapter implements B &#123;</span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BAdapter</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a.a();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而Proxy模式不是把A接口转换成B接口，它还是转换成A接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> AProxy implements A &#123;</span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AProxy</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a.a();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ul>
<li><p>隐藏委托类的具体实现。</p>
</li>
<li><p>实现客户与委托类的解耦，在不改变委托类代码的情况下添加一些额外的功能（日志、权限）等。</p>
</li>
</ul>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>静态代理是指代理类在程序运行前就已经存在，这种情况下的代理类通常都是我们在Java代码中定义的</p>
<p><strong>缺点</strong>：</p>
<p>当需要代理多个类时，代理对象要实现与目标对象一致的接口。要么，只维护一个代理类来实现多个接口，但这样会导致代理类过于庞大。要么，新建多个代理类，但这样会产生过多的代理类。</p>
<h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>动态代理是指代理类在程序运行时进行创建的代理方式。jdk动态代理、CGLIB动态代理。</p>
<ul>
<li>Jdk动态代理生成的代理类默认继承proxy类，由于Java不支持多重继承，故被代理的类需要实现某接口，代理类实现对应接口，暴露对应方法。</li>
<li>cglib是一个强大的高性能代码生成库，它的底层是通过使用一个小而快的字节码处理框架ASM（Java字节码操控框架）来转换字节码并生成新的类。cglib要求被代理对象未被final修饰</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" data-id="ckiwu72gz0000ukm03txe2awr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-设计模式-观察者模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2020-11-29T14:27:40.000Z" itemprop="datePublished">2020-11-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/">设计模式-观察者模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>亦称<strong>事件订阅者</strong></p>
<p>定义对象之间一对多的依赖关系，一个对象状态改变，其他相关联的对象就会得到通知并被自动更新。</p>
<h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="https://refactoringguru.cn/images/patterns/diagrams/observer/example.png" alt="观察者模式示例的结构"></p>
<p>manager会维护观察者列表，在接收到事件后 ，遍历列表依次“通知”。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/" data-id="cki38aoro00004om017uu5q5n" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-设计模式-组合模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2020-11-29T07:22:29.000Z" itemprop="datePublished">2020-11-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/">设计模式-组合模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p><strong>组合模式</strong>是一种结构型设计模式， 你可以使用它将对象组合成树状结构， 并且能像使用独立对象一样使用它们。</p>
<h3 id="使用意义"><a href="#使用意义" class="headerlink" title="使用意义"></a>使用意义</h3><p>如果应用的核心模型能用<strong>树状结构</strong>表示， 在应用中使用组合模式才有价值。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul>
<li>方式一<ul>
<li>透明方式，在抽象类中实现基本的方法属性，但是叶子节点也拥有该权限，不安全。</li>
</ul>
</li>
</ul>
<p><img src="http://c.biancheng.net/uploads/allimg/181115/3-1Q1151G62L17.gif" alt="透明式的组合模式的结构图"></p>
<ul>
<li><p>方式二</p>
<p><img src="http://c.biancheng.net/uploads/allimg/181115/3-1Q1151GF5221.gif" alt="安全式的组合模式的结构图"></p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/" data-id="cki2ubqke0000oym039ei31oc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-principle-bridge" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/15/principle-bridge/" class="article-date">
  <time datetime="2020-11-15T14:35:06.000Z" itemprop="datePublished">2020-11-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/15/principle-bridge/">设计模式-桥接模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><blockquote>
<p>将抽象部分与它的实现部分分离，使它们都可以独立地变化。更容易理解的表述是：实现系统可从多种维度分类，桥接模式将各维度抽象出来，各维度独立变化，之后可通过聚合，将各维度组合起来，减少了各维度间的耦合。</p>
</blockquote>
<h3 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h3><p>在类型存在多维度发展的情况，会出现类爆炸的趋势，<strong>桥接模式</strong>将各个维度设计成独立的继承结构，使各个维度可以独立的扩展在抽象层建立关联。</p>
<h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="http://www.jasongj.com/img/designpattern/bridge/Bridge.png" alt="img"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/15/principle-bridge/" data-id="ckhj8m2sr0000fym06bvv9pjx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-principle-adapter" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/15/principle-adapter/" class="article-date">
  <time datetime="2020-11-15T13:47:25.000Z" itemprop="datePublished">2020-11-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/15/principle-adapter/">设计模式-适配器模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而<strong>使原本因接口不匹配而无法在一起工作的两个类能够在一起工作</strong>。</p>
<p><img src="https://pic3.zhimg.com/v2-b2e8ef1c763884ea59bd87e53f791a4e_r.jpg" alt="preview"></p>
<h3 id="两种形式"><a href="#两种形式" class="headerlink" title="两种形式"></a>两种形式</h3><h3 id="1-类适配器"><a href="#1-类适配器" class="headerlink" title="1. 类适配器"></a><strong>1. 类适配器</strong></h3><p>创建新类，继承源类，同时还要实现新接口</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class  adapter extends oldClass implements newFunc&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-对象适配器"><a href="#2-对象适配器" class="headerlink" title="2. 对象适配器"></a><strong>2. 对象适配器</strong></h3><p>创建新类的实例，其中包含旧的类，并实现新接口</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class adapter implements newFunc &#123; private oldClass oldInstance ;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>类适配器使用<strong>对象继承</strong>的方式，是静态的定义方式</li>
<li>对象适配器使用<strong>对象组合</strong>的方式，是动态组合的方式。</li>
</ul>
<h3 id="知名产品"><a href="#知名产品" class="headerlink" title="知名产品"></a>知名产品</h3><ul>
<li>jdbc</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>将目标类和适配者类解耦，而无须修改原有代码。</li>
<li>对于客户端类来说是透明的，而且提高了适配者的复用性。</li>
<li>不足之处<strong>过多的使用适配器，会让系统非常零乱，不易整体进行把握</strong>。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/15/principle-adapter/" data-id="ckhj8m2sw0001fym01rlldptn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-principle-builder" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/15/principle-builder/" class="article-date">
  <time datetime="2020-11-15T06:31:25.000Z" itemprop="datePublished">2020-11-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/15/principle-builder/">设计模式-建造者模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>将一个复杂的对象结构与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>类属性较多，且部分属性是optional或者各自存在先后顺序</p>
<h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="https://upload-images.jianshu.io/upload_images/2836699-886b2e1cc08177de.gif?imageMogr2/auto-orient/strip" alt="img"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/15/principle-builder/" data-id="ckhircw200000prm09z05hdrr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-principle-decorator" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/25/principle-decorator/" class="article-date">
  <time datetime="2020-10-25T14:14:36.000Z" itemprop="datePublished">2020-10-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/25/principle-decorator/">设计模式-装饰器模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>当我们想增强类的功能的时候，不想通过创建子类来扩展，可以通过装饰器模式实现，被认为是继承的替代方案。</p>
<h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><a target="_blank" rel="noopener" href="https://www.runoob.com/wp-content/uploads/2014/08/20201015-decorator.svg">image</a></p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>功能可以灵活的绑定与删除<br>装饰类和被装饰类充分解藕</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>过多的组合会使得代码看起来混乱，排查问题比较困难</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/10/25/principle-decorator/" data-id="ckgp7mvh200005cm01orpby7o" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-principle-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/19/principle-1/" class="article-date">
  <time datetime="2020-10-19T06:27:24.000Z" itemprop="datePublished">2020-10-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/19/principle-1/">设计模式-责任链模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p>将多个处理对象串成链，可以让每一个对象都处理请求，也可以在某一个处理完后就结束流程，避免请求发送者与接收者耦合在一起。</p>
<h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img src="https://user-gold-cdn.xitu.io/2018/10/31/166c90b265849954?imageslim"></p>
<h4 id="多种形式"><a href="#多种形式" class="headerlink" title="多种形式"></a>多种形式</h4><ul>
<li>客户端通过list  将handler串起来。</li>
<li>handler 通过next指针指定下一个handler</li>
<li>每个Handler都有机会处理Request，通常这种责任链被称为拦截器（Interceptor）或者过滤器（Filter）<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4></li>
<li>一个请求可能因职责链没有被正确配置而得不到处理</li>
<li>对于比较长的职责链，请求的处理可能涉及到多个处理对象，系统性能将受到一定影响，且不方便调试</li>
<li>可能因为职责链创建不当，造成循环调用，导致系统陷入死循环</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/10/19/principle-1/" data-id="ckggckszd0000vem0633zazdw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/02/10/jvm-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">jvm-内存模型</a>
          </li>
        
          <li>
            <a href="/2021/02/10/ThradPoolExecutor/">ThradPoolExecutor</a>
          </li>
        
          <li>
            <a href="/2020/12/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/">设计模式-代理模式</a>
          </li>
        
          <li>
            <a href="/2020/11/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/">设计模式-观察者模式</a>
          </li>
        
          <li>
            <a href="/2020/11/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/">设计模式-组合模式</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>