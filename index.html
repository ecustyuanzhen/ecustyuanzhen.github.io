<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-ThradPoolExecutor" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/02/10/ThradPoolExecutor/" class="article-date">
  <time datetime="2021-02-10T03:09:49.000Z" itemprop="datePublished">2021-02-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/02/10/ThradPoolExecutor/">ThradPoolExecutor</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img src="https://p1.meituan.net/travelcube/912883e51327e0c7a9d753d11896326511272.png" alt="图1 ThreadPoolExecutor UML类图"></p>
<p>ThreadPoolExecutor实现的顶层接口是<strong>Executor</strong>，顶层接口Executor提供了一种思想：将任务提交和任务执行进行解耦。用户无需关注如何创建线程，如何调度线程来执行任务，用户只需提供Runnable对象，将任务的运行逻辑提交到执行器(Executor)中，由Executor框架完成线程的调配和任务的执行部分。<strong>ExecutorService</strong>接口增加了一些能力：（1）扩充执行任务的能力，补充可以为一个或一批异步任务生成Future的方法；（2）提供了管控线程池的方法，比如停止线程池的运行。<strong>AbstractExecutorService</strong>则是上层的抽象类，将执行任务的流程串联了起来，保证下层的实现只需关注一个执行任务的方法即可。最下层的实现类<strong>ThreadPoolExecutor</strong>实现最复杂的运行部分，ThreadPoolExecutor将会一方面维护自身的生命周期，另一方面同时管理线程和任务，使两者良好的结合从而执行并行任务。</p>
<h4 id="运行流程图"><a href="#运行流程图" class="headerlink" title="运行流程图"></a>运行流程图</h4><p><img src="https://p0.meituan.net/travelcube/77441586f6b312a54264e3fcf5eebe2663494.png" alt="图2 ThreadPoolExecutor运行流程"></p>
<p>线程池在内部实际上构建了一个生产者消费者模型，将线程和任务两者解耦，并不直接关联，从而良好的缓冲任务，复用线程。线程池的运行主要分成两部分：任务管理、线程管理。任务管理部分充当生产者的角色，当任务提交后，线程池会判断该任务后续的流转：（1）直接申请线程执行该任务；（2）缓冲到队列中等待线程执行；（3）拒绝该任务。线程管理部分是消费者，它们被统一维护在线程池内，根据任务请求进行线程的分配，当线程执行完任务后则会继续获取新的任务去执行，最终当线程获取不到任务的时候，线程就会被回收。</p>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><h5 id="coresize"><a href="#coresize" class="headerlink" title="coresize"></a>coresize</h5><p>默认情况下，只有任务到来的时候才会创建core thrad，但是可以通过方法， prestartCoreThread or prestartAllCoreThreads 来重写</p>
<h5 id="maxsize"><a href="#maxsize" class="headerlink" title="maxsize"></a>maxsize</h5><p>当一个新的任务过来后，</p>
<ul>
<li><p>如果当前线程池的size小于core，那么即使池子里有空闲线程，也会创建新的线程来处理；</p>
</li>
<li><p>如果当前线程池的size大于core但是小于max，那么只有队列满了后才会创建新的线程。</p>
</li>
</ul>
<p><strong>Keep-alive times</strong></p>
<p>默认情况，当线程池线程数量超过core，那么多余的线程在空闲Keep-alive times 后会被回收，但是 通过方法allowCoreThreadTimeOut(boolean) </p>
<p> 可以回收core thrad。<br><strong>Queuing</strong></p>
<ul>
<li><p>如果当前线程数小于core，直接创建线程</p>
</li>
<li><p>如果当前线程数小于max，进去queue，</p>
</li>
<li><p>如果queue已经满了，此时若线程数量小于max则直接创建，若大于max则reject</p>
</li>
</ul>
<p>通常有三种队列策略：</p>
<ol>
<li><p>直接移交</p>
<p>工作队列的一个很好的默认选择是SynchronousQueue，它可以将任务移交给线程，而不必另外保留它们。适用于并发提高响应速度的场景，但是需要core、maxsize足够大。</p>
</li>
<li><p>无界队列</p>
<p> 例如 LinkedBlockingQueu，此时max的参数不再工作，所有任务进去队列</p>
</li>
<li><p>有界队列</p>
<p> ArrayBlockingQueue</p>
</li>
</ol>
<h5 id="Rejected-tasks"><a href="#Rejected-tasks" class="headerlink" title="Rejected tasks"></a>Rejected tasks</h5><p>存在4种拒绝策略</p>
<ol>
<li><p>中止（默认）</p>
<p>抛出异常</p>
</li>
<li><p>调用者运行</p>
</li>
<li><p>抛弃</p>
</li>
<li><p>抛弃最旧的</p>
</li>
</ol>
<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>线程池内部使用一个变量维护两个值：<strong>运行状态(**runState)和</strong>线程数量** (workerCount)。在具体实现中，线程池将运行状态(runState)、线程数量 (workerCount)两个关键参数的维护放在了一起。</p>
<p><code>ctl</code>这个AtomicInteger类型，是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段， 它同时包含两部分的信息：线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)，高3位保存runState，低29位保存workerCount，两个变量之间互不干扰。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Packing and unpacking ctl</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure>

<h5 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h5><ul>
<li>RUNNING：接受新任务并处理排队任务</li>
<li>SHUTDOWN：不接受新任务，但处理排队任务</li>
<li>STOP：不接受新任务、不处理排队任务、中断正在进行的任务</li>
<li>TIDING：所有任务都已终止、workerCount为0时，线程会切换到TIDING、并运行 terminate() 钩子方法</li>
<li>TERMINATED：terminate() 运行完成</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/10/ThradPoolExecutor/" data-id="ckkz7f7yy0000czm00l8033b9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-设计模式-代理模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2020-12-18T15:55:52.000Z" itemprop="datePublished">2020-12-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/">设计模式-代理模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>为其他对象提供一种代理以控制对这个对象的访问。</p>
<p>代理模式，即Proxy，它和Adapter模式很类似。Adapter模式:它用于把A接口转换为B接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BAdapter implements B &#123;</span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BAdapter</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a.a();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而Proxy模式不是把A接口转换成B接口，它还是转换成A接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> AProxy implements A &#123;</span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AProxy</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a.a();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ul>
<li><p>隐藏委托类的具体实现。</p>
</li>
<li><p>实现客户与委托类的解耦，在不改变委托类代码的情况下添加一些额外的功能（日志、权限）等。</p>
</li>
</ul>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>静态代理是指代理类在程序运行前就已经存在，这种情况下的代理类通常都是我们在Java代码中定义的</p>
<p><strong>缺点</strong>：</p>
<p>当需要代理多个类时，代理对象要实现与目标对象一致的接口。要么，只维护一个代理类来实现多个接口，但这样会导致代理类过于庞大。要么，新建多个代理类，但这样会产生过多的代理类。</p>
<h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>动态代理是指代理类在程序运行时进行创建的代理方式。jdk动态代理、CGLIB动态代理。</p>
<ul>
<li>Jdk动态代理生成的代理类默认继承proxy类，由于Java不支持多重继承，故被代理的类需要实现某接口，代理类实现对应接口，暴露对应方法。</li>
<li>cglib是一个强大的高性能代码生成库，它的底层是通过使用一个小而快的字节码处理框架ASM（Java字节码操控框架）来转换字节码并生成新的类。cglib要求被代理对象未被final修饰</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" data-id="ckiwu72gz0000ukm03txe2awr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-设计模式-观察者模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2020-11-29T14:27:40.000Z" itemprop="datePublished">2020-11-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/">设计模式-观察者模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>亦称<strong>事件订阅者</strong></p>
<p>定义对象之间一对多的依赖关系，一个对象状态改变，其他相关联的对象就会得到通知并被自动更新。</p>
<h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="https://refactoringguru.cn/images/patterns/diagrams/observer/example.png" alt="观察者模式示例的结构"></p>
<p>manager会维护观察者列表，在接收到事件后 ，遍历列表依次“通知”。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/" data-id="cki38aoro00004om017uu5q5n" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-设计模式-组合模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2020-11-29T07:22:29.000Z" itemprop="datePublished">2020-11-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/">设计模式-组合模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p><strong>组合模式</strong>是一种结构型设计模式， 你可以使用它将对象组合成树状结构， 并且能像使用独立对象一样使用它们。</p>
<h3 id="使用意义"><a href="#使用意义" class="headerlink" title="使用意义"></a>使用意义</h3><p>如果应用的核心模型能用<strong>树状结构</strong>表示， 在应用中使用组合模式才有价值。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul>
<li>方式一<ul>
<li>透明方式，在抽象类中实现基本的方法属性，但是叶子节点也拥有该权限，不安全。</li>
</ul>
</li>
</ul>
<p><img src="http://c.biancheng.net/uploads/allimg/181115/3-1Q1151G62L17.gif" alt="透明式的组合模式的结构图"></p>
<ul>
<li><p>方式二</p>
<p><img src="http://c.biancheng.net/uploads/allimg/181115/3-1Q1151GF5221.gif" alt="安全式的组合模式的结构图"></p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/" data-id="cki2ubqke0000oym039ei31oc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-principle-bridge" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/15/principle-bridge/" class="article-date">
  <time datetime="2020-11-15T14:35:06.000Z" itemprop="datePublished">2020-11-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/15/principle-bridge/">设计模式-桥接模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><blockquote>
<p>将抽象部分与它的实现部分分离，使它们都可以独立地变化。更容易理解的表述是：实现系统可从多种维度分类，桥接模式将各维度抽象出来，各维度独立变化，之后可通过聚合，将各维度组合起来，减少了各维度间的耦合。</p>
</blockquote>
<h3 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h3><p>在类型存在多维度发展的情况，会出现类爆炸的趋势，<strong>桥接模式</strong>将各个维度设计成独立的继承结构，使各个维度可以独立的扩展在抽象层建立关联。</p>
<h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="http://www.jasongj.com/img/designpattern/bridge/Bridge.png" alt="img"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/15/principle-bridge/" data-id="ckhj8m2sr0000fym06bvv9pjx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-principle-adapter" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/15/principle-adapter/" class="article-date">
  <time datetime="2020-11-15T13:47:25.000Z" itemprop="datePublished">2020-11-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/15/principle-adapter/">设计模式-适配器模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而<strong>使原本因接口不匹配而无法在一起工作的两个类能够在一起工作</strong>。</p>
<p><img src="https://pic3.zhimg.com/v2-b2e8ef1c763884ea59bd87e53f791a4e_r.jpg" alt="preview"></p>
<h3 id="两种形式"><a href="#两种形式" class="headerlink" title="两种形式"></a>两种形式</h3><h3 id="1-类适配器"><a href="#1-类适配器" class="headerlink" title="1. 类适配器"></a><strong>1. 类适配器</strong></h3><p>创建新类，继承源类，同时还要实现新接口</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class  adapter extends oldClass implements newFunc&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-对象适配器"><a href="#2-对象适配器" class="headerlink" title="2. 对象适配器"></a><strong>2. 对象适配器</strong></h3><p>创建新类的实例，其中包含旧的类，并实现新接口</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class adapter implements newFunc &#123; private oldClass oldInstance ;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>类适配器使用<strong>对象继承</strong>的方式，是静态的定义方式</li>
<li>对象适配器使用<strong>对象组合</strong>的方式，是动态组合的方式。</li>
</ul>
<h3 id="知名产品"><a href="#知名产品" class="headerlink" title="知名产品"></a>知名产品</h3><ul>
<li>jdbc</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>将目标类和适配者类解耦，而无须修改原有代码。</li>
<li>对于客户端类来说是透明的，而且提高了适配者的复用性。</li>
<li>不足之处<strong>过多的使用适配器，会让系统非常零乱，不易整体进行把握</strong>。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/15/principle-adapter/" data-id="ckhj8m2sw0001fym01rlldptn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-principle-builder" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/15/principle-builder/" class="article-date">
  <time datetime="2020-11-15T06:31:25.000Z" itemprop="datePublished">2020-11-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/15/principle-builder/">设计模式-建造者模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>将一个复杂的对象结构与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>类属性较多，且部分属性是optional或者各自存在先后顺序</p>
<h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="https://upload-images.jianshu.io/upload_images/2836699-886b2e1cc08177de.gif?imageMogr2/auto-orient/strip" alt="img"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/15/principle-builder/" data-id="ckhircw200000prm09z05hdrr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-principle-decorator" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/25/principle-decorator/" class="article-date">
  <time datetime="2020-10-25T14:14:36.000Z" itemprop="datePublished">2020-10-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/25/principle-decorator/">设计模式-装饰器模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>当我们想增强类的功能的时候，不想通过创建子类来扩展，可以通过装饰器模式实现，被认为是继承的替代方案。</p>
<h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><a target="_blank" rel="noopener" href="https://www.runoob.com/wp-content/uploads/2014/08/20201015-decorator.svg">image</a></p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>功能可以灵活的绑定与删除<br>装饰类和被装饰类充分解藕</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>过多的组合会使得代码看起来混乱，排查问题比较困难</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/10/25/principle-decorator/" data-id="ckgp7mvh200005cm01orpby7o" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-principle-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/19/principle-1/" class="article-date">
  <time datetime="2020-10-19T06:27:24.000Z" itemprop="datePublished">2020-10-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/19/principle-1/">设计模式-责任链模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p>将多个处理对象串成链，可以让每一个对象都处理请求，也可以在某一个处理完后就结束流程，避免请求发送者与接收者耦合在一起。</p>
<h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img src="https://user-gold-cdn.xitu.io/2018/10/31/166c90b265849954?imageslim"></p>
<h4 id="多种形式"><a href="#多种形式" class="headerlink" title="多种形式"></a>多种形式</h4><ul>
<li>客户端通过list  将handler串起来。</li>
<li>handler 通过next指针指定下一个handler</li>
<li>每个Handler都有机会处理Request，通常这种责任链被称为拦截器（Interceptor）或者过滤器（Filter）<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4></li>
<li>一个请求可能因职责链没有被正确配置而得不到处理</li>
<li>对于比较长的职责链，请求的处理可能涉及到多个处理对象，系统性能将受到一定影响，且不方便调试</li>
<li>可能因为职责链创建不当，造成循环调用，导致系统陷入死循环</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/10/19/principle-1/" data-id="ckggckszd0000vem0633zazdw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-principle" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/09/principle/" class="article-date">
  <time datetime="2020-10-09T03:06:06.000Z" itemprop="datePublished">2020-10-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/09/principle/">设计模式-指导原则</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="单一职责原则-SRP-Single-Responsibility-Principle"><a href="#单一职责原则-SRP-Single-Responsibility-Principle" class="headerlink" title="单一职责原则(SRP, Single Responsibility Principle)"></a>单一职责原则(SRP, Single Responsibility Principle)</h4><ul>
<li><p>核心</p>
<p>每个类都应该有一个单一的功能，并且该功能应该由这个类完全封装起来。也就是高内聚。</p>
</li>
</ul>
<ul>
<li><p>好处</p>
<p>类的复杂度降低了，可以快速的帮我们定位到具体哪个类可以实现这个功能。</p>
</li>
</ul>
<h4 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h4><ul>
<li><p>核心<br>软件中的对象（类，模块，函数等等）应该对于扩展（提供方）是开放的，但是对于修改（使用方）是封闭的。尽量通过扩展软件实体来解决业务需求的变动，而不是修改已有代码。</p>
</li>
<li><p>注意</p>
<p>开放-封闭原则是面向对象设计的核心所在。  应该仅对程序中出现频繁变化的部分进行抽象，但决不要对每个部分进行抽象。拒绝不成熟的抽象与抽象本身一样重要。</p>
</li>
</ul>
<h4 id="依赖倒转原则-DIP-Dependence-Inversion-Principle"><a href="#依赖倒转原则-DIP-Dependence-Inversion-Principle" class="headerlink" title="依赖倒转原则(DIP,Dependence Inversion Principle)"></a>依赖倒转原则(DIP,Dependence Inversion Principle)</h4><ul>
<li><p>核心</p>
<p>针对接口编程而不是实现，抽象不应依赖细节，细节依赖抽象，高层不应该依赖底层，而是依赖抽象。</p>
</li>
</ul>
<h4 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h4><ul>
<li><p>核心</p>
<p>所有引用基类的地方必须能透明的使用其他子类，故子类尽量不要重写父类方法。</p>
</li>
<li><p>注意</p>
<p>如果子类不能完整地实现父类的方法，或者父类中的某些方法在基类中已经发生“畸变”，则建议“断开”使用父子继承关系，而采用依赖、聚合、组合等关系。</p>
</li>
</ul>
<h4 id="接口隔离原则-ISP-Interface-Segregation-Principle"><a href="#接口隔离原则-ISP-Interface-Segregation-Principle" class="headerlink" title="接口隔离原则(ISP,Interface Segregation Principle)"></a>接口隔离原则(ISP,Interface Segregation Principle)</h4><ul>
<li><p>核心</p>
<p>客户端不应该强行依赖它不需要的接口，类与类之间的依赖关系应该建立在最小的接口上。</p>
</li>
</ul>
<h4 id="迪米特法则-LoD-Law-of-Demeter"><a href="#迪米特法则-LoD-Law-of-Demeter" class="headerlink" title="迪米特法则(LoD,Law of Demeter)"></a>迪米特法则(LoD,Law of Demeter)</h4><ul>
<li><p>核心</p>
<p>也叫最少知识原则(LKP,Least Knowledge Principle)，如果两个类不必彼此之间直接通信，那么这两个类就不应该发生直接的相互作用。强调了类之间的松耦合。类之间的耦合越弱，越利于复用。</p>
</li>
</ul>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ol>
<li>分析系统中变化的与不变的部分</li>
<li>针对接口编程</li>
<li>松耦合</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/10/09/principle/" data-id="ckg1pfpdp0000gim0cyiq1yzd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/02/10/ThradPoolExecutor/">ThradPoolExecutor</a>
          </li>
        
          <li>
            <a href="/2020/12/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/">设计模式-代理模式</a>
          </li>
        
          <li>
            <a href="/2020/11/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/">设计模式-观察者模式</a>
          </li>
        
          <li>
            <a href="/2020/11/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/">设计模式-组合模式</a>
          </li>
        
          <li>
            <a href="/2020/11/15/principle-bridge/">设计模式-桥接模式</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>